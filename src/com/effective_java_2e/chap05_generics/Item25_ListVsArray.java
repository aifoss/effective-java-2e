package com.effective_java_2e.chap05_generics;

/**
 * Created by sofia on 5/17/17.
 */

import java.util.ArrayList;
import java.util.List;

/**
 * Item 25: Prefer lists to arrays.
 *
 * Arrays differ from generic types in two important ways:
 *
 * 1. Arrays are "covariant".
 *    If Sub is a subtype of Super, then the array type Sub[] is a subtype of Super[].
 *    Generics, by contrast, are "invariant":
 *    For any two distinct types Type1 and Type2, List<Type1> is neither a subtype nor a supertype of List<Type2>.
 *
 * 2. Arrays are "reified".
 *    This means that arrays know and enforce their element types at runtime.
 *    Generics, by contrast, are implemented by "erasure".
 *    This means that they enforce their type constraints only at compile time and discard (or erase) their element type information at runtime.
 *    Erasure is what allows generic types to interoperate freely with legacy code that does not use generics.
 *
 * Because of these fundamental differences, arrays and generics do not mix well.
 *
 * For example, it is illegal to create an array of a generic type, a parametrized type, or a type parameter.
 * None of these array creation expressions are legal: new List<E>[], new List<String>[], new E[].
 * All will result in generic array creation errors at compile time.
 *
 * Why is it illegal to create a generic array?
 * Because it isn't typesafe.
 * If it were legal, casts generated by the compiler in an otherwise correct program could fail at runtime with a ClassCastException.
 *
 * Types such as E, List<E>, and List<String> are technically known as "non-reifiable" types.
 * A non-reifiable type is one whose runtime representation contains less information than its compile-time representation.
 * The only parameterized types that are reifiable are unbounded wildcard types such as List<?> and Map<?,?>.
 * It is legal, though infrequently useful, to create arrays of unbounded wildcard types.
 *
 * The prohibition on generic array creation can be annoying.
 * It means, for example, that it's not generally possible for a generic type to return an array of its element type.
 * It also means that you can get confusing warnings when using varargs methods in combination with generic types.
 *
 * When you get a generic array creation error, the best solution is often to use the collection type List<E> in preference to the array type E[].
 *
 * In summary:
 * Arrays are covariant and reified; generics are invariant and erased.
 * Arrays provide runtime type safety but not compile-time type safety and vice versa for generics.
 */
public class Item25_ListVsArray {

    public static void main(String[] args) {
        /**
         * Fails at runtime
         */
        Object[] objectArray = new Long[1];
        objectArray[0] = "I don't fit in"; // Throws ArrayStoreException

        /**
         * Won't compile
         */
        //List<Object> ol = new ArrayList<Long>(); // Incompatible types
        //ol.add("I don't fit in");

        /**
         * Why generic array creation is illegal - won't compile
         */
        //List<String>[] stringLists = new List<String>[1];
        //List<Integer> intList = Arrays.asList(42);
        //Object[] objects = stringLists;
        //objects[0] = intList;
        //String s = stringLists[0].get(0);
    }

    /**
     * Reduction without generics and with concurrency flaw
     */
    static Object reduce(List list, Function f, Object initVal) {
        synchronized (list) {
            Object result = initVal;
            for (Object o : list)
                result = f.apply(result, o);
            return result;
        }
    }

    interface Function {
        Object apply(Object arg1, Object arg2);
    }

    /**
     * Reduction without generics or concurrency flaw
     */
    static Object reduce2(List list, Function f, Object initVal) {
        Object[] snapshot = list.toArray(); // Locks list internally
        Object result = initVal;
        for (Object o : list)
            result = f.apply(result, o);
        return result;
    }

    /**
     * Naive generic version of reduction - won't compile
     */
    static <E> E reduce3(List<E> list, Function2<E> f, E initVal) {
        // E[] snapshot = list.toArray();       // Throws error on incompatible types
        E[] snapshot = (E[]) list.toArray();    // Throws warning on unchecked cast
        E result = initVal;
        for (E e : snapshot)
            result = f.apply(result, e);
        return result;
    }

    interface Function2<T> {
        T apply(T arg1, T arg2);
    }

    /**
     * List-based generic reduction
     */
    static <E> E reduce4(List<E> list, Function2<E> f, E initVal) {
        List<E> snapshot;
        synchronized (list) {
            snapshot = new ArrayList<E>(list);
        }
        E result = initVal;
        for (E e : snapshot)
            result = f.apply(result, e);
        return result;
    }

}
